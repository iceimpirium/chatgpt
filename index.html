<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: template_color_primary;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: template_color_primary;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: template_color_secondary;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Passphrase"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = 
    ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassphrase(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())

    const templateError = 'template_error',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"ceef067d3938cf56e3617aa7aa9c5d84d643e9c5dfbeacb0f191259efe70bc2544e10bb35c4451fbe4f32cbfe9b43ff1c922f44d54dc181975f5af8a7004ec678438bb2df059e773a21c7438d90154068554496283f37c1a579b690de6a350b5a154612abc4f6a486af65c8eb701a9ba5b3f8ad31847706c0907de1e8ff6914ecda1b5c9f6e88175134c4dc7def3a631f4f80d75fd907a57bf131e50a3d3ecfba69a86dd2322c7bcf25fe60ce98685f714dea9b97b39fd39bbf1286cb990c68ff46cc018d95b112a62f1e4ab57d86a4890a8ef039f6b1e0fca97e96b7291ee121eedc6b70f95b06811a831850358cce5c68e7eb84b000fe9db94ad6ee958dc6e79658925dce184402f69ae26831c741126122cf5cec29185295f9d6d172b5cb8a80a680056efb9cf1768f684762a8c99892c3e5334f9ba0fd4246b8f1585461c931e39383850a760754cd07b32de653ed2c4f5157380612140cfd8b4ed55f777f6350f41c324fa113d0c3452aa4898298f58bf443fab64ea71f466355cdb2d7f62bfbd665213621cdb31bb4d853526c877c856f0913458c7489cc22a15196a8790b2fc5dda9ff8b1ed9dbe7102e60b25308f565a9e19b3abe5766d77e3ce20dcb6d8c94332160c410536dd2cc7d535e725bf0b0f9cb22884ae4af1d715301027e08328022f8a9c292631bc07533119f6bca7176447c35e5b21db4fe9a7b9ecfbae62061ef00fbad03a1be7c27814f9e4ac5fc3039899da47f8bc452fb166bb91f8a8d8087adc4a6668de02e8d529e93a1e9d09544badf8b272a7f3a611558b56306a26390bf2a1b196049a5c9c5843cf7e15bacfcdf92eb9980a40bc4916bb8cb7f5b5a2e3ee97dd3cfbfab3250cf616786a865ccec2644d1276cafab0a77a35d669731b370840ff350da034c1dc199b9bdaccee38ca5006b91e6b57ef34b53161d843df72e6c9b795e1fc74f03a7164820c20b560ede9bea3bf4857b5ada04f3ee464cb9148911d9eec6c348682c4b7aac25a3753c743ebd4d1e9dc2f4cdcf5597a1dcb8f23aee656bcbb038c69ac12340552e25a3f5b5e59c33aa57c2168881515ba7a90ca28e09bf791e573a372a4bd3009e061c0e0da791b203668bf1a97b9b52687bc64c0ed674e668094f03ed03268d70d01ca050fda9c08fc0e161725d02c3684622057cd13b7606394bb65f7b2fd6a1752e642e0d3153f82894288c9a0455a4c3bc834ea72469af6ffe790ac84d7632e68f71637af58d70d50146a77b11662a8d4a1b1b67b9b01cc435ee2c2e60b83b937b3beb1a74eae93c4c740c65a8c3d08ec27b5451d6cc3ee70f368dfead4b35ce76416f0395e92bf51e44de8f3e80be573a2342d3e02130fd737065d664f60399b79d7cd83b8ee809de24db8a467e18bb36664374f1f216ef52dc13bac66af433007a1e68f13b8d5a76ea8356b0937f99e2ce4eff751859ebed16b5040586a3616c31d4699dc5e3b29f8aee9fa010610b2ef609b7cebd119c4a9f1e06b8d570799c084ef29c9b409afcb60b6a901855e9b3de740cf239379752b6bd6d266f639289dcb4aaafdc2230b81c51ea31a69d5da99314f01cc0652af14b68b2d9a2469e5da62256e786096535a97bd33684e54e0424788d6cdf9a2ba51877b47f24f50c34df1ddc2e05667f1aa3b533a8f00cfb58b3d2772fe8547cc85e0cc87e3976627047b6b13c99d9ddb1293da7635b213a526d33ccd5a39723320c59febdb9951308cad379a642eae00f64825a4dd529ac6654a062424d58d69ced1c42bc6b0a8a02462335623d95de9c5696a70f20f595f281773293b7bdf858c2bbf5ceb2a063197fa42877f5a4e690686ebf79d4921f54219d7f5afd84c6d7d41457f3ae91cab5f983eb78bfbd2b7972dfee537ce1d9e1cd083fcc6f5608d923046b7ac90bb2068dbcddd7494573e5795e82fae523b5304e3aa30722f9aba0eb35107969a2210623de79428e8c067d5e252bb917283f774965b5b8385b0e70c5d9e4a6a78573332f725ab3ae87f53d12b98c8b9f02c4853c142f14053170b618b8deea6b70242f079c9571b745be6cfbb9080f9b20798a3fa5e60a35c08b2cf2ce7f5d71b34e178b5d94f8fb50561e42c913e9aade3492eafce5dc06675208dab246525f9dff689760086e06ba07709e30061c88fd99e029a292ee99b94bf390d919ecc228523af9fa4b0ebf8cc18c7ee439e03fac841324a0b4cfd87ea85b93c3f4c1a5ad13f3d573e42044f131915f81d0866f32133cb624c4db7f295a707e411304f7fd6d3561bc1b00b64a91ea55ba3578ebc69af638e86df88d047110a73a35ed1fdd2f959430adb3f77d27dac1846951ae3c505683935b3121548ef629d3cb9b12d39d381738b4bdddd14e23cd1098d356eaa3372e8a604b6a0912c2dc4c75d84868dda6b3f344d53f6b659f1f20ed2c63e9fdd852f6f433d40f251766257b33db1d84d55734ab16623a506a742c2e7d2ca64938764c2ef4d1dbb6353825c0df8ebb8b6103866230815e7acb05413122b379d813b2dd048d4bb90501bf4fadf7a305a999ea3d7ece9249323fb6bb1bf06a9092995e72548bdeecd5eb9c516a909d91b5a02719a439445af8c0efa3e23954d19fc32c1d21635c208adf99d0fff3288fe1316e0b2e7bf8cd9b5bd4869b28dfe024734681ee8c98d3b3c5e53be0dfd93b1de7525ed9f6787bcf0b09a262ae1b55d6b2ea122db2f0fa975faec69b38fb731753f68329a9723a270e33a75f8ad79bcf2541dbb030aa122fe9e77826d59f9a2723c3ea8600c08e7b5ba6e4616ed24e4e0abd6c07be3bf038926d478d3aaf55fdfcee499ce0f56bcacfd0f8c259ed1cd14d8ea4907e486054906c5761c0ba875a3e9644fc279d3e321686652e1aed5c59b138a992b9e0df3fdca03e709f993e97004e7d192c0c4f79605e387b68ee96960ee64693d8d6e7f2f5ed577be347393b5269b59cad687c6291047757175e09907fdb130dacd98122a79f8499ba6d93537be32c83adff7929f4a62c91be83b5944a397ec1f113fea00ec802a20b8f45d12b50b0d736f48cdd8cb1ceba50e9a6df7698b299bed0788a20cf687ec279e4f8cf92afd9287e0c76d58ae74a3e6e0040839f09199ace62b9bc7542132629fb610357822ff3ff53d07f38cdfbbc9239d748f774af18884cb586100efcf0f2ac7622de3f92653d87585182ac7cdb5af6c972351a34895950b01a35a8eb89a20484e56bf160d7c8e6b3a52d98e2ffd096950dfa009a2f338e8c6593de2c3fe36b5f0c3787ca352978c02589fe98c4e30ab38d789a9308c64231142339fe3f13f77cb27e9a7674d68ea68ed855ef66db1402b89c94251579f3255483417fc4937c2431b67f62ef450aeb0ad14b69d91051a318978fe9e71211997fb8d2d887b4f598b9aba7463ec8f26494359d0d7a1129cdb09ec1de20d164db72a571b9970dfd04ed0657d2bfbea6e5dc3fa92886b1b8682ec358e916e660a6934c7cb743b9be2d6b001c3f080ab3462b7eeee8e32f17e56d81c6a960e7afdbd5340f9e9323623d17594bfa06efc6291beafe965ec53aabf7e5e151115477356a53108eba4661eb6105e9640be85943d7b3b0e59299632965f00ee1e8efd3d6894e2ee1fac6d8045720e39c5ec0a050de19c68e36d368c0b1c9feb9a8052e2cace3b7ed4ed094cd42023130d64c7c59aee756c8d9ae248f81163c4b1f84cc955d8c1d0d19dd839a33f9ae85e0f14c84a23f8031ab43c4be03979530dd7037b385297c3e142dd2cd5e9eaf81b574174d5b575176fcf1dffbc383998f38775bab17d101245dd7a431b2cbcf00cba7d5a8156544f2adb5f907e4dd71df6158f215833d2f7ab20af07a09973faa7b789b7c8886417589ab57ff8559c8f90643180cbc1fcd057ddd74d6ec3029aa5d2d9622be768bb7596c5cf8d970c1e42bec133e67f3a3b8ae3b35ab5537c194832781a5b42c472e975edd80460874580af4dbe0c2aafb845a2106cb55e072b425d878c2537aa24a3151b9fde0bdbd9a9c9a8af8205c7846984e33ecf4a51582b05d95fd361aaef22602374f91abfae6e3805f19d80eca413e8c0419f5d621dd5ea9383f74ebe2d981ba65b430fcd3ccc31f82c9d63b0ff02396563e53eb58c438bdba00c75873234e62782470df281a2cc44395b1717eb3d8b2596f6ebde88abd67404b90b9f9665b28679b79b1d129fb3cb8b7f74e0056266b199b1fd881e0daaf8777176798716369d0e38cb6849b0735dd3eabe45eebc8a9cc8f370f7a264476f2098364f8dd1b76bd679b9093bc8d169ebbe2ac64d6a4d1379a2c9bb0fa9cf3ccdb5b192d697a6dbc2007d4a9b01ad35283113e0d0db7ce5c02423c7d855a1d468fa55bf095f3d41031647d73ef9e6926434771e276a1a764f4449caec253ff323190cec0112600d0c29d2220765711141e68e694144d2a1adb8ec55f7606e2f25200dcacbb7860e71a1c205b586e6351973c88c9ff48e068c4472cee69f720e8cbdd9859004ce5a3ceac398affd874571b657827f2b2bb6e5d124740d0b87ae217c5a5f2748b604228e2fc68e295f1642fff4fd0a710621dec9c8985e6872c18a8acf9539c724bbe40e3201bd600753f27fb0ccb142060f21b21e6e4cc9b977f3a1af8d212cd21efc95df0bb81fa981b88de9fbd23cc5cfd195bd0070fe16edfc4b2921ae07d1de68575fd4836949c63454bd37e996566af2efc3c199f4ee4271f845e23d621cb2ee3d483279b0bebdb19da606e50c684c34b38cf674f8206403d152ff4d304f663853dc4636d95ca84e8613749148aa7e6bce8a9eaf87c2de1c714ad51a7c20be6323d065980802f0e9f7f89b8d5d87b1f5b02460aa098b569c98a3c6fa12c601c3646b502f5ad8d2f6ae4277960289004897fec5c7d871f691d42f9e3dfdcfca498f1867a4c3c32f5c6d961275fcf9069af573b5333754f64e0fb2b506e0336f0ef0b8ab6ad636a75bc5ba51b5fecb29f69614ed342be8726b2f3eb1c32c1a9e92943095108e551cb1d38545a220ccedd9196ac36f6a1fd458717a6f770746c833e3726455801163a0c87ce612217995116e3ab94c61cf927009efa15d4a7d6281ee49decd3c94f260531d2dbbf39a9b14d6ce0be9b94aaf621af3b1958965a9f5b271a2754a9170916a79fa671005a550b425c78dcf618af6dddce889c76879960121fbf7a3dd02482a5ba576c9b7ea70e07891e43ed15bbbcef50de8794a11cd5edf203679acff6cc8bbd1e4fda9b505c5d4b55502a3a22dbe95320bcdf97f62b92eb906c30f9bd5707ba83a6dc459462a2993e56ef2166e7071837e65a1084198d2c381aa54452a1b8e58c6e71ed06299d1eb29c6327982b507797e3ebdaa92ee928be12534ec7ec19394885a56ffd4359fb17ef52edbe3595653141ce4fdf9973dad5840b957cbc2e25c57c9174af1ca3645429748d9f5e0e5b3184108513644a93d675319e1a1ea6a8f11e7a2b172ade7f42b8ecab61683a318f7869a9c6cae21456830070cd195835360a0b288dda2c44e5a68370c78e61b3ec8560ed1414e35cbbcaa1c376eb83643a123dc9b7bcded7542b716e3762c98c1ed92f390c07000f360b81cd118151f086b4c3a4b9ccf84092e92ccee72e41b210e3181b2072050c0a2bd7987cfc3044e0f6c66a4994c2330ade7dc4f349a63bec287e71400c85ade8f0b5b323596d0d61ecbd2e2d8bba77ad1feac65c2f129dc5cb40a91844a9e20ce9395ede27a830ce5f9eb3713882d8036f49eb40b5a8971da84bcd1606a9497b774b6dfc6eb48f0e1d91b691e6b6df4899bb57062309ae402655426d56f6dbf958c033c14c7964a6822a4513cb5e8a14858fb0c1e89ae2747699afd4a3e1705aab5b8957866db03a9b2d12154a2580f33968638f0d8ed5d13f94bb646121ec8ce169e973ded8f065074bebff52a4a22110aec74035592b09c1db432193086835812a8ff2f6ea77cfec3c9202734650709798d371e7c0d6ca04330e02843a0df756f40b06fbae7896fcde24ad907376773d1c0cf22cfc90d46992f93e871209f08b52ace9e542096198f6c68c3aee4078c79e7fcfdc1ee5786ab51531d50f6fc595b89f90ecfe78c19ce7575b3cc2a2dda94f8cabaa48ae25996c57a4d0521f4f754725c44df92898c6184c1ccc99f86718f5a6e4f428057bc926e382e9a3a328d519fc44f89cf9fa2642bd5751fdf0b5adf26fc9f1e95e57df93c7d80cf14d41eed9055233361698ee934e946b1802e330d940c273167247b507180bea28a552680e9363efd72805d9c04c8c1144c57546bb92c5bbb7f4509551d78a23095b72ebdbe01038282b60aceee3a6fa5e0df5245bafe4d2f291057cd7faba8447d8847cce9fd1057a82b4db8e5d818265997f474b4884f29f9b03b558705a5e69604ef3f39bd3e11a8b24d5cfc0c3b53d2bb2e3c4a600356ab76aa578369eb3def7e85937dd76afad8c5d9d92fef65852aca283568e1b766709c6a0799618c765d792e96c35ccd2ce779363aeb0ab25ca7ad1adcff8bafd0a6b83073259a4094ec37c7b61ed47e2041cf4fa628c60d7de2c20ec045dc166f84408878b0796ebb7eb2cb34ac211a47b5e43556b7ddf48cadd3f249d14004ae3c51a061f1439ad6d04cf0576bf15bc3cbd2e230725ffb900163b7397dba77ba0a6b1cdf9f473e427071f6d0ddd4feb33215b8049ff69dab0e447c1b78b16961f66229ec2d7893af90374ddafc1f552c0afdcc97d13ea743687c0b8d465dd5cd459526be2732435d88ab0af7b61b1dccb66cbe2e76aff5c4c21b15fecd5b972b4ad3003e30bbc4433c9b607daf6ce9d3e9f35c502307f3de6016110d1333e37fa0d4ac8e10915ac903475de1da9bbb1c3f529baa6d2027a7416af5ed3892a614dbcc24c1a9e388cbc618c3d07804c85fa9f79d4244bf76760dfad03e8299be5fc7dce216c5471d42af64056702a0f7ca582c82c60ed99475c20e9799fa49821d3552f6ada68e0b5a6dfe3c6f4d98ace29141281aca1600472889857b2251097f115ac522014f15cd13baa5b2ba84d4cba1fadf0a49eee0dbe559f1a9c174ddeeb19ca317012cb969aece7d56fcd1236ab01cc4978c13bb635e86fbc125a2c796766a55495caa9da15d2829dfa302524bee8ee806314e2805cbe89ef16f8957e833807663d4a0a4d13340165285ea3e47ef3b34690c82eef699f78fc8c6e7a1f7206a70f2c0a86065e6d632ee6e8cbe5a5b6f1d5a5ae27070de5da4093b5b931bbef886c5cbd22a301c95876def11c0d8ce8e3ed52f19bf48cd7c2b2874621aca83cfd1af1e9b56722fd9be4c1dc37cbebb9b9386c68255edfaef3c571b3a1b0a7c74a4766e07d42285b0615213f52b9de2b4f765610366fed3f01d15aba26f2856502cd03610539710731ae166e125a6a5608778969bd9344a946cf6752c46dd1f39ecf0bb683087ca749cfeffce4ebca811697e3954ce08e10606a3be4ce346ab908d1cb04bc08fb690006f4bc83864b787e93f11bb7605c933d3e62f31d745f2a54b1c411ed0472f90d5b66ba74b447e1ed4e253fa68e0fbd27320589d2b23c703b819db400135be27a06e8ddc764d58b31ef426d9383a479b9e9407c540f56f5593ed3720e250c5176213b80cbd76e1a66519f3dd27f6149be46a6864e75f4ee1130a3a7095874273765af822dcfaae4a6752cf86bfe9da2cfeb732d1210392316cfb53ed50de071f6c95e2fcb6e80ea642a519d931bf7630f1c1e67736d2ab42e0e570cee47b3816e313551862b55c5dda83df44954c53fef0b812fcc8a17b562adaf645a6917f7276a2a20b0e7258dd82ba51ed0b2a211b8de16c252befdeec782a21ca2f1445433dc7ab7d70d76be23edf1154ce3c32bf1d30b29485cb577e4e5a5a9d93108d9f470bceb45518ff7479135fa7c649c6aef2a2d7d3f2b385ffd3187862237ed4104c2f7cc15589ae78715c4da795923c75e1d50fa0c83f693ef1cd7e232b10ff50b85f251b6c9718560292e4c2bd8d5ebc6c2a2a4c8fe70b312916f3f7f5a0f203092a0263544fc69ec13b0a528cca569e03a60c7c76240fafb542ede26add7bbf5f2e2c61039ebf60fd7ab7dc9d0f4f02916806e63f4fa6a7f769b1d2027845fbf0b878bb6cd36d9dfdd6d25363e909d5ad237d2ff4a3654eb806235d0a5db42422f592a6f2300b77aa36a7cb97aa95b9899f8b48cd282d18e5b8ebc5559693ce8317190461921f1fd52e0448b1fdfdb34f4af713733d2a9bfe691e561b8f05b2015c64304cc88afea6e35e872389c6d05fcf770743850f0d25d14a0ef0a6f39ef0260843140c1a685621e3ceffa8476c37f09921b6034bff75d4522211ac406ce516aae8ff9f529f7f9ee89e6cf23694da10f56ea62f286afb1819b0821aef225ce2adf91128164e8d7bceb8f6667ac221ef7c02cd615d04b13ed5908060f19c05f5abcaeaa9e399e4a3b117acf99f252383fe9b9610690697246affb7fbd23642923ff582b06d0b21e014c2afb666cbf0c2f0d3dd926f26b0f275516ac1e19d96b4754aa6fa83441041a291d4b249bd0d206031f3e41b7f0c9a65fe75f671649cfb1e6d774b1332efa1d63dbe722a1ecc0e874e217c62db90e59ce406e399d7ecdc7eb9a7ef353601345ff308e50e92d5097d765fc9a3847eb9eb91af52f4e765cc558aedc59a1cd2fca6ec30db382b124a8657896f44a8a993b06332e292b0bec53dbaca01c8623d3733447e580dba241e13f9715e90108bb5167d548d9a8a6360c3f78f3e8fff662c1069c9caf29a7bfe4d9ef027b94c8929c678d06cfaaaf3c9155acd03251bce721e063a850a6dcf69488d0d3f186567b46cd06c141aabf89e2d231e8c2cd6c815088781499a32e28ab98356bec9279b32e24a247e2395db639aca5d958e3a25d701cc898a15a1d174c663f293b17a78c9464cc437bdc55e370f2eac53a1222c78982771a3c332112411d653ac6d027699e97e630d9bad9b2f43320a32f7bc75768f734631ea4bfc349dc67b1e89857195d448c73aea0e36f8665877653c168977595b06a9f17d9fc9c8dd491fa5606e350bb6f4538552716b134e70690b35faf187a7031a26e55d62514467a59497afe682682fae5d610481dd11d8eb0e878c69dea49c2eea81bd5242e1f439c3aa94a880d0de9b76200b601432b44fd411a87ca2f289cfa1d2ebeeeb3085a3fcac4ae4a8fcf5afe8892c1254a48bc8dbdefcb3c8c51e27f64dba6a292158964fd945846743f64aad1e1836f8b69579d72878bbc8ed29f97240da6f6aa250485209450e629f9f6642b0d4dd0380437107a18b9c9bf34c72ac7af3179f7975e4d86927b719bc7c75a71d09e9fd9661451bc7e0658b606431c9a0968a1325682e3ec8a301959eb55f6b967b43bad690514fbc0973d414df3d65eb45732de8aa8ebf140b236287f91e53a06bb14deae7711016aa9621d1684f56ca871ee92901c00dd7666788330347cb5d82c963b12091b0f078ff8e1f4b94291fd3957bc5827bbab65bb38932eb0f287f6a811a47caa9802d78038d154226eec2da4abdd633724d4c543eb749494f0b6bed859483df795a01181eeaab34fdc2de2aea4ad49b6caa99f2c832a0dd51667ddd6591b2f6d4a46ba5ac6a53d682b90309596931634bafade17771500eaa5f1cf6c653cf0ad4bc789d3385110bdcc405f3105dcb4e1a6162b2bd900ac9b5cdfbf452896e35a95699fe11abc266893f237d3d5718c02ed704212667c247cea2c1caa8e507c496ee6b61a79a096b621021d8b98e71223aefc4ef860e88b8df58acf16a6259766737b3241421626fc8a7ea329ad0575d20b58b20b4339dfe32a84540a50e611561e8c562dd4c1f63a329c4e7c0ad08e11737910c7b9ff1c540054f4aba087991b0301020422dce584239cc85043cb99803403c3cee1ab7bba28ed2b8afe871a21df20240584967414b1b0ca9462b269ede9910b1941471003209d11bd624db579c86afac09f31ced3dc6f9805a5308979690c5dd1cb73d233b81e81a9ef5aa22fd99fdd629cd2e67a2f4e8c75f1e9121550d6bd34745d4b87ccb121a831225f69a5a4e1bcf84634dab7bfab033f551ced17b1e7881eeeedae0ff4093c84aa86c76c8377489ab5afa891274cbb1f3ff8e24ce933d2b754f1bcda607231b28d3fc615c717cda1d736c1c4e5407ab5eb739f01f052bd09c8b447252baf7297a4ef9dac28dda8c5310e6ddf9283e59db33d2273ef7f2510d5f4953bea7770cdd69470ce20aa52ab65bf499e039c9d071fe82f8c7bb155f4fa0d8ca4e9bc99ca7cbf0d5bd3f369a71ea76e0a90bc4510a28f526d183d6d546efe008032c72e4ba073d7480c195970499e0f35d14d71863590835d00a4976b64a02c9fe0dbe0d0a76166734451d672912136945d814b1c2369292f96f7722b6feb2b7d944ae4b31d554f78dda85cbb1bbb18cc1843a0516be8087a2f73bc3c3d09a8b6e2dadf76c30586d694000e414c13bb49b53bd1a110d46749da3bf55493fa74bb1d1eb16af9529c898e954c6281b485745da1159989d78f90fddbdd223fb7b6083598edce003a0da50955331905a84d1d89422c0e1a1f47bc64f0186437c9d878f319f1b25e26bebff906ef71519d41e4e5996f78a6cb94d987bc42bde2bb33b1f72d11505bfd9ee2dff8ca0f54e537b50a87aa5096ad1260187a46ab14325d097bdba334df816564f3663d697561dfd57ddc26710e4cd08d526a04d799c5ae1daa726767a30fa26096887eef69e1b1b97021e698be4b843b74c53765c79a393651943d7342a5a41387a7817cf9abc4fc41142b96980da216ccecd6d26928aa8418a0a48a498576ae6e627d5c830de247a6e68aae27437e9351d3fe2f894f53d15b316bbb2a7db2458957020cdf6d9f9a80d59864154cb8835d57bf5446d9523cf609ded4a07dde2cd7537a92d146614c60fe05c4f2979e9209d218e3b7c209313a1357be3268ef8f1e1095597737d89952b5f87bb6097444ba4f51436ae9b7dfd1eddb4a84f15217f68edd2f2a2e1cd6bd29a0410551688d6596c669bc96cd104ddfbfb806d001273802012602cf778967f344e2f9e6e18f06b2bbac6d705894cab4c23dc370c5ff19bc5ef49905b74c32caf5660b0dd042a50dde4d99845d53986f41509f70b737cbbbd489fceeb8e486b414bc0be8858cf5e6c6cccede152d7e0c75bbb791ec8998b8105f68c3ae37c274cdb6610f06f04877477e9864315096b05a6e3c49a3122eeca79dfc9540ee7d51b5a2e402331bd867a0ab256311f9d06304173e4d8b62d8a75b450bd5f81eaacd2e01cae08d91d31df181bab2c3d6babf505620790b07d58ef2a93213ff9a68d42a08d12891928a56202b46e527f13a4abb80fbd208c72011c624988aba188d4cb0ebc1925dd1a041e9be8329a040e3f64d69dfdfb53db40e9dd0ebb251becdf68b9ea6a13a6a56b678f27c447c943f59315c155402ac3ccf4897973c3f9ba6f47a9b7179aba6ceeb86d8111ea58cc48c6283ac58ca562c156656040edf0cf48ecbb98299d3a23e9763433e13305c33a10ac0d77b0c6f51d25b85c8ac70aca13b70b8f3d5cfaa363dbe2ce158e4010fca30ee816b8ff0b36d8f6e05080f1b698003744372c345bf11cb41627dee1e3b0b3f2eb105a0871e70267ba6e37efa8b3e7c5ed16a45eda49eead0df55376a5ba5034c184ea9272505d163ee3e5911cfd052de4827778a1c53de592a89b143aa54ad5790b73d272dc05bc0874bc9a3bbfcfccc32f2f55993383a802fdca720424b47d130cccf5134df85e7bcadd5d035edb9e5d9408f4f5c659b3d925c80b42995535dd23e566759b423c1824f8b69b55f0c2675cd6ec3d3726e87fb6d16c445fb9f028f973457c6a493f7fa8a7e495d7a871fa4858292fb8da25358cbc1a15b84f27dd4b1f54737693a585f1984b8f652d6b7fb056f19f3a6a52d701affb01990bab30a744d379115c5666ab74bb3249a9b3570707df7756a9fdadd19dfbcd074f8d89efcb74829966dd2fa09dfa39a72218957fe6c46fc578c5ca4d3ad2ff8ed2a976702425a162afd9c1d80dba3b0b5672f5615ff9c1e6e262bf1ff5501ada401bb6ff3dbb273b90d33c5a65a206300a3db5059910b936c3eac2ffcc08bb85d7c9702868f3533e255ec7670d77e76d4e466986cca61aa84788fa0d9bf8a7da3616689d06f3d3a758d0909af9e60e3d6f086da74ef1b429dbf24db8a6218957b3253cdd28a2623bcbecdec83697248efa077768f1a0ce9e63ae3e8383edba49683dcb0ff4f6068dff4bceb6c152446c27416f1a394712c2817116fd24e1ae96ef9e22365eb935716a3dd7ad25c047421fd964b5d1d77e066827b2b3cc60dfe6b495febda08f57d7f5ae1f76fb09dee6976758e15aeb1b63c79634223db3bf5f7cfd641bb1ad0f00e805529e5cef573ad32051684e1d8f02cdf7f0bab8aff5d9e576d2dd087f4c16d224eaf6d54cce17801ea3177e4b78b9ad90f9f810d5f5aeb0ef7b3228db1381a87ac9cdd06aa5ed15cb40f881aeb910cbbb4656f13149d1ddcb48a077eac6504f00abb0aa234160d1c325d0972a3e9cf7a4a8497cf87e91e530bec269fa00bdf56cf89f87cd700ca15d1321a694a03ddd260fbe367339c64a88ca396a5dcc257a4ae43f8b108e5b109b3aca3e2f2cc9a7635adf8243b141b27315656bd3fbe0db232511a3151af52dc93c024e16c94f4845ecbaf2637ace5d387d52c8e0124632025d65fafd889c3f404c7c8a725aed669083191c4025b3459708e4014fc0edbed772b774978d401999d2f50caa43e4a453d18e8fd2a10a39fd5298a9834ff4b086fd9f52711b7690a5b6d4df3b6a4716d21caf4bff696d53ea75eaa4d6fe1eaf57385d2b97e8a202facea28a83bd69498b52f7637cf7a04fc63e527d112d330c32b989d4895c39ed7d7ac2c5639dcf2b94613f06af9c9f64af7169483f50e529401909701765c6761f240c7366de02c9e362a6adf2c808d45ac19693749ba536a56db536ef7991c08b3f4067e136acc2245520018e5d2d8150a983227ce4c17a5a57e73ee43510fe31dc6f85476fdf4b1e727cb422d7a2dee5413824b4befb81728f2358e40533a82427d2c3af7f3f3abd57d202d4346ecfd0c6ef027b6d4a69fc21225a08e2c075fa57d2a86cd01c99a7d7e460f1040e3fa1c7bc666325b0eb1de91cd50677c56bcfbe6f967a25c847a0b97c586030962cf0e654a3b728866993d24858092085d95d7066864da1a1d6a38b363395771b0de7b2ff79951b51cdafe66811e720a8a279ac38b6981f14c3df0a5a9ed6fe8817ac6badd9066acd4ab7895b91bde6861796e41e9d041238a92581039e4c597369a758239161661668dd65e8e3dd0e3008a49856e448432e58c1083617fc57198a05264fda7813a527c56dc4a39fa008f7f8db6aa8e8541d973ce8a6100c6988e82db1df8641765491f50381dbf47a8c8e64248809e9775a739b84fc57d701728a27d82892732676c6ad7056cc3459b902c9846d516b176180512bb3325b4a8fc04e54c9791aa38ea6e04c9ba1f12e88103fb0fdce67af374b1343767a905f8238d133af6ebb26af3312c56586f8a705cd4337061fdc9ece99066db0d01a70b6b0cff53346ebbb28754146a1cc49ef6ffda58e564ed91afa591d8b3f1c37bd97df3167f5ecbb7ae7a086e875dc5b741a6440ddb72246232c655a40dc8ba0e9e1b00c0731357ea85dfab839602d1494765ca62c6cc40a935eb69f48b9b032ed9b1383a6779e0d455760e374c2954e44c28fca55f5a609b682ea54c27acd33bc3266339dc8aca6850dbf4a3c18b350c1978f78016f237505d7768a65c7f6b9cbb2f01ed64065db5e358b04ff0a037e03aa98954591aed4d5f8c14a8c3d5a5e7cdce12343e3736953167ccbb6db5c520a7ecb1f9c7b5fb8ee0d24f59ffa3ca63c43a853f460e45a9f9c87798a565542f7c225d6e34b2a9b7532b3c5559003b97a038aa0511e27900ed29477b7aadd0fe18e75a2a42850abad92b382f18fad33f7ac02272595bd669545d372cc3ecb3843f3ff3a1364e615171fe67833aebf1e4e56d9c71c98a7e73fa75ceea1014b1ada9079e45a6e07883131702ca586f6f1af957678bfd9417ebdb72bdb5e0a818f31dcb082705d31e107b43c8ca7ab05097ef40536452cf076fc208a59a6cd3e6ef2e13fc046e0bf8bf4a55a9bf27598e80036f4f4c01fe0ec09c82df05227bd9a9f22582d2ca4bb2d9ed6f2e601d2fb605fba3063df5a9a1c5fe599a7b7cab670ea339e2d4269c3b1c27551df316994c817f35a4250d94b29e27d37f3ecc97a895ccfcb5b71fbf56c02f03c610004f87633a5fda7d83fa1a4b83e4a8e37eed3153a122502b5af5277cdc88768821967356cb90fea312da968339062ae69eed5c9a46af169c2bc5ce5e05dc75eba3dd37131a6285dc09221f52198d0585ec627d29ac61e3dc377a3333f701262ee9d0a4752df5a515d2a21f3512ce9e691c64e6c386e8cf919f1de9119f0972b4d919854c264681a8aa45177a7c7a7ce96934ff9891725991423a50f4ff8ecd9acbaede41fa317a31d7590671dd591920ac438e8e6e9e77ebfabb13238baa422a33f7c3fa87793ad1423727bb0f8016c684bca14937afe7de303bf5dd246e7503c1ec488a53ad5c6e2d4c147fb6fc44b36516f6a1311b4e8f51de1152254a7249dd577f754aa9d48a521ce50fbe6914ebd341772c8d0cb1ae2a7badba5204eb9d7f270cfae2e3fd4602e8d14fad3c46a1a17f76fe7ace1d73dcf7fae52bc727f04cb4c783f41674eacded5f199a043ccd9c7db683e27077ed37b115d170db51d02aa632a167a8bc31a57c2baf9a0877add5495d1389c074bc7959b2db1901abfabb46f45c3b4fb99eda16b4176f880f3ed865873498585c27f00b971258b517a6bacd27d3f8819fb34278374de477cf88be75cb811fb0c25003decb64c17af62817835bae10cc5d2e8789034dd8845da78e26465ae57d4b7e6238460ff99435a94e5a9f4b11960630c5344cac4124925fd2be987a1524b537ae764963405d9968d7bc3cbf511e780e081115b6b9433456a8568529670cb92766d19bfd166e0726bd8693a82e1403320346b3ad177d15af868533b2b6b7d1d476cafc4e059c8b7db8acc514e36cc0c09fd229af5dd105569eb8b71efdc618f7ff6b62a4af58a2a17621d9b7b45b13b5e7b7362ea822ebc2ccdb320541937a89e70149e18b1c3fc7dc8fbe76e5d52264fa3800cb33478061bbca863d2edccd5ef1a3f8310b57ef90385f63d084ceeed1ba73fe868cc899cd34fea842cb05569f124543714cdefbf91cbd7b04989f069f7454cfbc6ec6c8c8508896c45cac51e5679a339e11dd80b22b47efe9b5c58553b805bfc082d9992d7af2a95b8889630bebdd07812959b547a323f3de9402c88ee8d9ceb253ab1716e213f1d8189222b110c928b7b03aec51f153a51a99f0a0560de2c39954df3eeb7932979471b69674099f098ea486a7fdfb93dfe97ced08ffc93c9636af2122298f1eebfd3eb9f80867f7347feae4f2c3c6db62edc3450f901bd576aa17a0a4e3c859567cd390baffb3892779e15330ddd7e0ea214104260422b5659f9f11ae5de7d7716c7abed07a88186bf5957dcdee97b25c6e6abcbbc87579003339eb89aabd44da3e66a1dc8371ecc17b5534cac0b2b213732446e22b634669c16bcc1f9f1f73101a7681c6d7c5004df6568bf4715cf29229f6d582ea43138888e54cf36c71776e3adb751e81fb332edbd2f7ff5610b0c24833465baa7561813a2ab41c4186d9b171d8fedb418c31a714941e22f9a5231cbbcff05d794c9c544f43a79b06854aa4715d10d2964742ac6891339a9eb0280af2607c1901f2b37befa10b3fa35e753849111469f7edfef6ddf8ca5fe17cbcaeec84a2c90fb736e3970dfa614f946c1ba72669a60641f36259005795b88be257f88db3f3f44fb4b4cecad067a1ac5e33733ac51856edf0fecfdf853de5ad85cd023fc3efce199fbfc8fe37b716a1eeb5cf3d331b8bfd7b7dc590835d1c7a005c2455a7916a8a7f1c4da7d08e9013510aea17f0d7d3158e2cc04909709e9d5ce98857aa83731f2d6eb341a132c4a0d2b659875030885df93c674e1036eae003491a6be27d4b3e2c74982ce0739f6995e282658290973abd9a994266dd1c65219c35d183c4c0b78b40555075ea88da16e10d15635416bb6543f582871dbefbc2d59d13a5acf933c8b1d19c1e81a9bf2b5b9bcf5171d368a0b872e504ead68abf0c1d825d61b001da1449272ebc63c01383779a3a2ed320d9d46344c1d17757a3405b7ccb1e3809d0eb78d5fb600c628333db717c0a72c061181f2614d199d0bb350efa7edddf4770bbd944c6aa2f0ba1f0be4e8926285a0e21300800e692ec01845eae0eb124f64c58370a30c199ae43ca0d6a8f15dfdd942cea8640071fea2b657ea2e5d645f19c64491193b79aef88594be9b5e87efdc16888cd6ab7cae25c5b591971ec1695e57f56079b308da190af3ef594bd6b03f276f768e216d7d0b36df5c530c7879d38083d414b486985647e8d09c6e9c3261e59baca82b6ede4d1a85cb0ec35e5b12adc9224b87c74fd4b02ecfac62775b1c4b7aa18bec43fa863fc7b9c39974d865f76bc2987d6e42623c81aba9527038b6c9498cfef32c388f2259496c298d40dbba2d3d616eda2e1e7b73106e0003f1d6bcd9cd0ecff3e44416f4971e1094d0852280cc93c68d1ebf54c5da59f15bad94b86a91c1bdc2adee0446bc4ba51436716afbf7e6503fc01e43eb003dbe64e3fca0c366f178a89f212ee083a9596c98a32491df40415015aef9a51e284ac0cf89e0fc55895a9d7cc608159ed4de8241f4abd231cb7e0964e34e69f1a8ebd0fd79df43c0f6b183628ff2daa34c279b18b644b34a3d9f5b08b165e720e348973f837f92c832c3f20ecf6f9fb4cb3e36c69a9bc8268f885a749e551cd54bbccc92eb2969d63e7750e0323acb18d09b27324f3be75bafcea348c28f6e1548c7c23e3b004e17e5c15208ba96c10567dcc3c457b517aaaed0555b19b79ad0c281646f3ea5b49458c88faa034242c894a37fb8591c45d0162155fd82518ffc69b1855ff01e440df640d9e70a0c7d82e844e1713f0aed61a1768e74c8093231624811920acec90ba81315dfa5bfb5bae84f5bf24c64ee73caaeefe15f75d203db542df930422c834d0ad64d62694ca350c30c5b38e46766a09366807c0c8c69da5caf03c1aedea10003f260e1e3f0802102bc849bc673a33b371b65479ad4b2291c6a6d919cbac34661d109649abb003e6035ac13ab0ef201047e10224d540bb196cf3a8f5f26f9efd97d712de6fb5440cb3fb5dc1fc79ce384696ae924cf6c600ea110c1c582f4f4508f23f2e2453980a23bbe04ab5cd20db230b6d1e71590ca749df95b8a62779259f4bbae7c9756b65e4ae5f2c594fbe793380936d0628839fa9482ab6a4175a99c01f42f94b5869c76a9edd50e172a8de46bfaa4cbbdd8b160b23538d50d50194f48b854307f60b48d880cbfa114c219024937611a6e9dd37a60984322f2c2e13480bbe8df49ac17249282e115d83a73b1286c3b9836da64afd6ebf241639931af288c519a7dc247c449fa65d683780a49500bf790e81d86d0367c6667826a35d899f7049ae6ee3cfb1ae633c6a794727caa9f96da5e5c3bacb18a1617878be747acd9510fea2f09fb9ae32b1c559cc520cfe43fe9b9cb4fcaf486636d2a976277f4a2418284fc0eb77a549bf8f1bf9be161d9bb2906f425b53fff58ef4b9e277dc318314c3df3c3da7e76f80387b5fcf0823ddae5f9f6705ce6e66ea76feac7ce3e43eebc0b3c059aef430f38de30c24ff94ea9104084a327059d8d1a99d6de3b23992a59d6b744cd2af67fd49186cb47fffc98752838d0eaf82f4fe8ff4de990a35207d71ea6793ff1036d0acc06ee6426c33e563a0d0fc5afc81d3cbc73d8c73ad0406d3cfb21add70e377588d2bc0d674879af8a1ed1f56a13f0bc50a928c11b8d2d9b99a3816a8f0d29478c5685307161c77071a9ee3dc035f047addf415d4ad9169817b24ef3fdea4fa22804bde4ad6ee4f525dde82663fa47894f571d8ceb33e9dd35a70ce2f530305870852ad6103a4d7c124b7a5daf3d65286c37364f997ac868fdb36e85d252ab3ca031cb33f98f02a574b635c037774066f90789fd9a925c80e06c28306734af99e2bfd467aa37384417c80da0cc9badbf676be5e5ca11483017f4676d546ffed5d73c360ed21fd52a61d6c883e254c5a60721fa1fdbd43a92ead74f3f2ead2cd4a08ad40a8bb334258fbb227689d7ebb03bba4e254662ce79a5dcbd7784981cd20497f1e1f4bbc30042dc9521442965f83eda8ad12a5dc7f99991d847722f715c0b96d3fcca896315acfd4bfa42c3301b51df432cf23d1aa097f15ed65821953897cc42d9a05c664e19d917a158d6de2cd6841d50642c95e81a441d666f2ed522dfe3bf799ddeab49f0a8b1a32f528a72e6faac59d1b6a1355a15d1cdbf81c607edaac306e513542ac6aa091e846a2bc9f44ca3f7eab4a04e3a927ba2f60344c2791b495e2872ead5dee05c585f79cc61023b6fd1ac98e3a3300d39223791a2eaf09da2f3a00671ef7f8d07f68c670b41ab004918eaa7189d153b988a53a6ed653fb98446577d83f99b362e0ad05ec88ed61da28dbdaacd9d510b52ecd824908e493f5409f8c38b997eeea6279f1f27ec40c09a18b1d6c6da3b477f09e77c4a94da7a2b182925c903c2c039b0feac9d7f29294314a5ca68a0c4ddc8e70d9d206441a0e938cf1e2737bdb7244732cba9ccb78781a3eeee3d5aa293e8d838b736663e3a439ffcd6a157c691dec4dfe59601d6f2573332e4f360e8b2777b69cf0d3cfe7b4100ec944f59571b649229c5fe7dd8e9431af5844db57025ca87cc4fa4fc1715226212761c23256af908ae94ecd1367629e6c4340801e4175dd508499b2a6beead30c5baf89df3b8349e663ad041bae29714b9696078f5ea35eef31fa6b712dff2aa68095927e8ede1fbbfb689edc7f1eb97a67c4b9a3ecfc8c0e8f89a9478995908fe2fc66678f7843ebd377d8518ff160017aa3c6240a6691bceea191038d8a84d2e2c6206d7a3ee887de9e6c8923819a9c2455e1ed8faa26c4a836d538d6fb1364c6dc7d9cb553cf30cb02d9cfbeabdc6aa097a0a625f94edbf7446a78c20629f1083f64b6dd6cb115d77e198cb4e218863d39196b9f67e4e56827ce7e9475686fc595959395feb49afb0919f6b656b3d6ac2a3b46340867b8f458e9642f9b7d6b3d3e42bc77882ac57f459609a59b10935ff430c313af2ddc8e85b025b5efee6f1012affe4e1f6306fa278036c2c98fc5fead5d5b6989226349f5fbdfd585c8e447b82537c7b257f4f86f8751665cffc96bb81508020a32f3ba7b8fb00e98c9d570d343fab06bc7ba02c24d5765b148dc1d3c88c64e435cdd78e75f2254a13dde1744311e85b31e1c674b6b4ecf15b0959d24fa91d1e2e496f55bdadd2d5c523638054b3256db2545b62817266b42652813630e323eb8ac789cdde69fade3dc04abf079e8d2d19cd11e7f0c38b20d6f4b3d60e29829eedc41c0781f5a03f966808d9f94c87a562fcf0e5a6ba1ec590a381fcc12240f332db0a95bc044951e94a","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"18a27cefc5e7a18dcc55155c11fa97c3"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(passphrase, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
